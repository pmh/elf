{"note":"Don't delete this file! It's used internally to help with page regeneration.","google":"UA-35665736-1","body":"# ELF - ECMAScript Language Framework\r\n\r\n## Introduction\r\n\r\nelf let's you create reusable and extensible programming language implementations in JavaScript.\r\nIt currently implements abstractions for creating parsers and lexers with automatic error-recovery and easy handling of operator precedence.\r\n\r\nelf takes advantage of JavaScript's prototypical nature so the way you create Lexers and Parsers is by 'cloning' the ones elf provides which can in turn be cloned by more specific ones. This makes it very easy to extend existing languages.\r\n\r\nelf also recognizes that you sometimes want to use rules from many different objects and it provides two ways of doing just that. The first is `extend` and the second is `borrow`.\r\n\r\n`extend` copies all the properties from one or more objects to the receiver (works with both parsers and lexers)\r\n\r\n```js\r\nmyParser.extend(mySecondParser, myThirdParser);\r\n```\r\n\r\n`borrow` let's you reuse specific rules from another parser (only works with parsers for now)\r\n\r\n```js\r\nmyParser.borrow(myOtherParser, \"+\", \"-\");\r\n```\r\n## Installation\r\n\r\nThere isn't an npm module yet so if you want to try it out you should follow these steps:\r\n\r\n\t> git clone https://github.com/pmh/elf.git\r\n\t> mkdir my-lang\r\n\t> cd my-lang\r\n\t> npm link ../elf\r\n\r\nThis will create a 'node_modules' folder inside 'my-lang' containing the elf module.\r\n\r\n## Calculator\r\nTo help you understand the basics of elf let's use it to implement a simple calculator language so create a file called `calculator.js`.\r\nThe first thing you should do is to require elf, so enter this into `calculator.js`:\r\n\t\r\n```js\r\nvar elf = require(\"elf\")\r\n```\r\n\r\nThe next thing we will need to do is a lexer that can recognize numbers, operators (such as +, -, *, /), here's how that could be implemented:\r\n\r\n```js\t\r\nvar CalcLexer = elf.Lexer.clone(function () {\r\n  this.number(/\\d+/)\r\n  this.operator(/\\+|\\-|\\*|\\//)\r\n})\r\n```\r\n\r\n`number` and `operator` are convenience methods implemented on top of the lower-level rule method so we could have implemented this more verbosely with `this.rule(\"number\", /\\d+/, this.helpers.number, \"literal\")`. Besides `number` and `operator` you can also use `name`, `string`, `regex`, `eol` and `skip`.\r\n\r\nSo now that we have our lexer, let's try it out but first add the following line just under the lexer:\r\n\r\n```js\r\nconsole.log(CalcLexer.lex(\"1+2*-3\")) //=> […tokens…]\r\n```\r\n\r\nNow from a command line execute `node calculator.js` and you should se a list of tokens.\r\nOur lexer has one glaring issue though, try adding spaces in the input string (eg. \"1 + 2 * 3\") and run it again. You will now see the same token list as before but with the addition of 'error' tokens everywhere a space was found. Let's fix that, add the following line to the lexer:\r\n\r\n```js\r\nvar CalcLexer = elf.Lexer.clone(function () {\r\n  …\r\n  this.skip(/\\s+/)\r\n})\r\n```\r\n\r\nNow that we have a lexer that we're happy with, let's turn our attention to writing a parser for it.\r\nThe parser abstraction in elf is based on Vaughan Pratt's Top Down Operator Precedence algorithm, for more information about it read his [paper](http://hall.org.ua/halls/wizzard/pdf/Vaughan.Pratt.TDOP.pdf), there's also a couple of blog posts about it [here](http://javascript.crockford.com/tdop/tdop.html), [here](http://effbot.org/zone/simple-top-down-parsing.htm), [here](http://eli.thegreenplace.net/2010/01/02/top-down-operator-precedence-parsing/) and [here](http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/).\r\n\r\nSo let's implement the parser, there are a few issues we have to deal with, first the '-' operator should be able to be used both in infix and prefix position and the '*' and '/' operators should have a higher precedence than '+' and '-'. Fortunately both of these features are elegantly handled by the \"Top Down Operator  Precedence\" algorithm:\r\n\r\n```js\r\nvar CalcParser = elf.Parser.clone(function () {\r\n  this.prefix(\"-\")\r\n\r\n  this.infix(\"+\", 10)\r\n  this.infix(\"-\", 10)\r\n  this.infix(\"*\", 20)\r\n  this.infix(\"/\", 20)\r\n});\r\n\t\r\nvar ast  = CalcParser.parse(\"1 + 2 * -3\", CalcLexer);\r\nvar sexp = elf.sexp(ast);\r\nconsole.log(sexp); //=> (+ 1 (* 2 (- 3)))\r\n```\r\n\r\nHere we specify that '-' can appear in both prefix and infix locations we also specify that '+', '/' and '\\*' can appear in infix locations. The number we pass as the second argument to infix is it's precedence level so we assign '/' and '\\*' a higher precedence than '+' and '-'.\r\nTo use the parser we invoke it's `parse` method passing in the source and lexer, this gives us an AST which we then pass to `elf.sexp`, this gives us a nicer representation for printing to the screen.\r\n\r\nHowever, since this is such a simple language it would be nice to just get the result of evaluating the input rather than an AST so let's do it:\r\n\r\n```js\r\nvar CalcEvaluator = elf.Parser.clone(function () {\r\n  this.prefix(\"(literal)\", function () { return this.value; })\r\n\t\r\n  this.prefix(\"-\", function (parser) { return -parser.expression(70) })\r\n\r\n  this.infix(\"+\", 10, function (parser, left) { return left + parser.expression(); })\r\n  this.infix(\"-\", 10, function (parser, left) { return left - parser.expression(); })\r\n  this.infix(\"*\", 20, function (parser, left) { return left * parser.expression(); })\r\n  this.infix(\"/\", 20, function (parser, left) { return left / parser.expression(); })\r\n});\r\n\r\nconsole.log(CalcEvaluator.parse(\"1 + 2 * -3\", CalcLexer)) //=> -5\r\n```\r\n\r\nThere are two things to note here, the first is that we now add a prefix for the special '(literal)' symbol and specify that it should return it's value (in this case a number) rather than an AST node.\r\nThe second is that we pass in functions to the `prefix` and `infix` methods, this can be used by regular parsers too in order to add more information to the node, and indeed for more complex syntactic forms they are necessary.\r\n","name":"Elf","tagline":"A DSL for creating reusable and extensible programming languages in JavaScript"}