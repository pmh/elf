{"tagline":"A DSL for creating reusable and extensible programming languages in JavaScript","note":"Don't delete this file! It's used internally to help with page regeneration.","google":"UA-35665736-1","body":"# ELF - ECMAScript Language Framework\r\n\r\n## Introduction\r\n\r\nELF let's you create reusable and extensible programming language implementations in JavaScript.\r\nIt implements abstractions for creating parsers and lexers with automatic error-recovery, easy handling of operator precedence and (basic) AST walkers with support for pattern-matching.\r\n\r\nELF takes advantage of JavaScript's prototypical nature so the way you create languages is by 'cloning' existing ones can in turn be cloned by more specific ones. This, combined with the ability to mixin and borrow rules, makes it very easy to extend existing languages.\r\n\r\n\r\n## Installation\r\n\r\nThere is no npm module yet so if you want to try it out you should follow these steps:\r\n\r\n\t> git clone https://github.com/pmh/elf.git\r\n\t> mkdir my-lang\r\n\t> cd my-lang\r\n\t> npm link ../elf\r\n\r\nThis will create a 'node_modules' folder inside 'my-lang' containing the elf module.\r\n\r\n## Calculator Example\r\n\r\n```js\r\nvar elf = require('elf'), _;\r\n\r\nvar Calculator = elf.Language.clone(function () {\r\n  this.number(/\\d+/)\r\n  \r\n  this.prefix(\"-\")\r\n  \r\n  this.infix(\"+\", 10)\r\n  this.infix(\"-\", 10)\r\n  this.infix(\"*\", 20)\r\n  this.infix(\"/\", 20)\r\n  \r\n  this.stmt (\"print\", function (node) {\r\n    node.first = this.expression();\r\n    node.arity = \"statement\";\r\n    return node;\r\n  });\r\n  \r\n  this.skip(/\\s+/)\r\n  this.eol(\";\")\r\n});\r\n\r\nvar Interpreter = elf.Walker.clone(function () {\r\n  this.match('-', [ _ ], function (node, right) {\r\n  \treturn -this.walk(right);\r\n  })\r\n  \r\n  this.match('-', [ _ , _ ], function (node, left, right) {\r\n  \treturn this.walk(left) - this.walk(right);\r\n  })\r\n  \r\n  this.match('+', function (node, left, right) {\r\n  \treturn this.walk(left) + this.walk(right);\r\n  })\r\n  \r\n  this.match('*', function (node, left, right) {\r\n  \treturn this.walk(left) * this.walk(right);\r\n  })\r\n  \r\n  this.match('*', [ _ , 2 ], function (node, left, right) {\r\n  \treturn this.walk(left) >> 1;\r\n  })\r\n  \r\n  this.match('/', function (node, left, right) {\r\n  \treturn this.walk(left) / this.walk(right);\r\n  })\r\n  \r\n  this.match('print', function (node, first) {\r\n  \tconsole.log(this.walk(first));\r\n  });\r\n  \r\n  this.match(_, function (node) {\r\n  \treturn node.value;\r\n  })\r\n});\r\n\r\nvar ast = Calculator.parse('print 1 + 2 * 3;print 4-2;');\r\n\r\nInterpreter.walk(ast);\r\n```\r\n\r\n## API\r\n\r\n### elf.Object\r\n\r\n**Provides an abstraction for JavaScript's rather clunky implementation of protoypal inheritence.**\r\n\r\n - `.clone(initializer<function|object>)`\r\n \r\n  \t*Returns a new object whose prototype link points to the object being cloned.\r\n  \tIt accepts either a function or an object with initialization logic which will \r\n  \tbe applied to the new object.*\r\n \r\n - `.extend(…mixins)`\r\n \t\r\n \t*Copies all properties from each of the mixin objects over to itself.*\r\n \r\n - `.slots()`\r\n \t\r\n \t*Returns an array of all it's properties.*\r\n\r\n### elf.Token\r\n**Represents a lexical token.**\r\n\r\n  - `.create(type, value)`\r\n  \t\r\n  \t*Creates and returns a new token object from the current one with type and value set*\r\n  \r\n  - `.error(message<string>)`\r\n  \r\n  \t*Turns the token into an error token*\r\n  \r\n  - `.pos(pos<object>)`\r\n  \t\r\n  \t*Updates the token position*\r\n\r\n### elf.Lexer\r\n \t\r\n**Provides a lexer abstraction on top of which you can base your own more specific lexers**\r\n\r\n - `.name(match<regexp|string>, [action<function>])`\r\n \t\r\n \t*Creates a rule for matching identifiers based on the provided match object.*\r\n\r\n - `.number(match<regexp|string>, [action<function>])`\r\n \t\r\n \t*Creates a rule for matching number literals based on the provided match object.*\r\n \r\n - `.string(match<regexp|string>, [action<function>])`\r\n \t\r\n \t*Creates a rule for matching strings literals based on the provided match object.*\r\n\r\n - `.regex(match<regexp|string>, [action<function>])`\r\n \t\r\n \t*Creates a rule for matching regex literals based on the provided match object.*\r\n\r\n - `.operator(match<regexp|string>, [action<function>])`\r\n \t\r\n \t*Creates a rule for matching operators based on the provided match object.*\r\n \r\n - `.eol(match<regexp|string>, [action<function>])`\r\n\r\n\t*Creates a rule for matching end-of-line operators based on the provided match object.*\r\n\r\n - `.skip(match<regexp|string>)`\r\n\r\n\t*Tells the lexer to skip anything matching the provided match object.*\r\n\r\n - `.rule(name, regex, action, arity)`\r\n \t\r\n \t*A lower-level matcher that all of the previous rules are based upon.*\r\n \r\n *All of the above methods accepts an optional action function that will be invoked when the rule matches. The context inside the action is the matched token. It can return one of three things: a single token, an array of tokens or undefined, in which case the lexer will ignore the match.*\r\n \r\n \r\n### elf.Parser\r\n\r\n - `.advance([id])`\r\n \r\n \t*Advances to the next token, if an id is provided an error node will be created if it doesn't match the id of the next token.*\r\n \r\n - `.expression([rbp])`\r\n \r\n   *Parses a single expression, if an rbp (right binding power) is provided then it will only parse as long as the next token has the same binding power or higher.*\r\n \r\n - `.statement()`\r\n \t\r\n \t*Parses a single statement.*\r\n \t\r\n - `.stmt(id, std<function(node)>)`\r\n \r\n \t*Creates a rule for matching a statement. A statement can only appear at the beginning of an expression.*\r\n \t\r\n - `.block(openTag, closeTag)`\r\n \r\n \t*Parses a block of code delimited by openTag and closeTag.*\r\n \r\n - `.prefix(id, [nud<function(node)>])`\r\n \r\n \t*Creates a rule for matching prefix tokens, similar to stmt exept that it can appear multiple times in an expression.*\r\n \r\n - `.infix(id, bp, [led<function(node, left)>])`\r\n \t\r\n \t*Creates a rule for matching tokens in infix position. Can appear multiple times in an expression.*\r\n \t\r\n - `.infixr(id, bp, [led<function(node, left)>])`\r\n \r\n \t*Like infix except that it associates to the right.*\r\n \r\n - `.borrow(parser, ...rules)`\r\n \r\n \t*Let's you borrow a set of rules from another parser.*\r\n \r\n - `.token`\r\n \r\n \t*Always points to the current token.*\r\n \r\n - `.tokens`\r\n \t\r\n \t*A collection of all the remaining tokens. It has a `.peek([n])` method that let's you look at the next token without consuming it.*\r\n \r\n - `.parse(tokens<Array>)`\r\n \r\n \t*Accepts a collection of tokens and returns an AST.*\r\n\r\n### elf.Language\r\n\r\n - `.name(regex<regexp|string>, [action<function(token)>])`\r\n \r\n \t*Creates a rule for matching identifiers based on the provided match object.*\r\n \r\n - `.number(regex<regexp|string>, [action<function(token)>])`\r\n \r\n \t*Creates a rule for matching numbers based on the provided match object.*\r\n \r\n - `.string(regex<regexp|string>, [action<function(token)>])`\r\n\r\n\t*Creates a rule for matching strings based on the provided match object.*\r\n\r\n - `.regex(regex<regexp|string>, [action<function(token)>])`\r\n \r\n \t*Creates a rule for matching regular expressions based on the provided match object.*\r\n \r\n - `.eol(regex<regexp|string>, [action<function(token)>])`\r\n \t\r\n \t*Creates a rule for matching end-of-line operators based on the provided match object.*\r\n \r\n - `.skip(regex<regexp|string>, [action<function(token)>])`\r\n \r\n \t*Tells the language to skip anything matching the provided match object.*\r\n \r\n  - `.stmt(id<string>, std<function(node)>);`\r\n \r\n \t*Creates a rule for matching a statement. A statement can only appear at the beginning of an expression.*\r\n \r\n - `.prefix(id<string>, [nud<function(node)>])`\r\n \r\n \t*Creates a rule for matching prefix tokens, similar to stmt exept that it can appear multiple times in an expression.*\r\n \t\r\n - `.infix(id<string>, bp<integer>, [led<function(node, left)>])`\r\n \t\r\n \t*Creates a rule for matching tokens in infix position. Can appear multiple times in an expression.*\r\n \r\n - `.infixr(id<string>, bp<integer>, [led<function(node, left)>])`\r\n \r\n \t*Like infix except that it associates to the right.*\r\n \r\n - `.borrow(language, ...rules)`\r\n \r\n \t*Let's you borrow a set of rules from another parser.*\r\n \r\n - `.parse(input<string>)`\r\n \r\n \t*Accepts a program string and returns an AST.*\r\n\r\n### elf.Walker\r\n\r\n - `.match(match<string|number>, [pattern<array>], action<function(node, child1, child2, …, childN)>)`\r\n \r\n \t*Executes the action if the type or value of the current node matches the match argument and if the provided (optional) pattern matches.*\r\n \r\n - `.walk(ast<AST|Node|Array>)`\r\n \r\n \t*Walks the ast and returns whatever your actions return.*","name":"Elf"}