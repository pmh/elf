{"body":"# ELF - ECMAScript Language Framework\r\n\r\n## Introduction\r\n\r\nelf let's you create reusable and extensible programming language implementations in JavaScript.\r\nIt currently implements abstractions for creating parsers and lexers with automatic error-recovery and easy handling of operator precedence.\r\n\r\nelf takes advantage of JavaScript's prototypical nature so the way you create Lexers and Parsers is by 'cloning' the ones elf provides which can in turn be cloned by more specific ones. This makes it very easy to extend existing languages.\r\n\r\nelf also recognizes that you sometimes want to use rules from many different objects and it provides two ways of doing just that. The first is `extend` and the second is `borrow`.\r\n\r\n`extend` copies all the properties from one or more objects to the receiver (works with both parsers and lexers)\r\n\r\n\tmyParser.extend(mySecondParser, myThirdParser);\r\n\r\n`borrow` let's you reuse specific rules from another parser (only works with parsers for now)\r\n\r\n\tmyParser.borrow(myOtherParser, \"+\", \"-\");\r\n\r\n## Installation\r\n\r\nThere isn't an npm module yet so if you want to try it out you should follow these steps:\r\n\r\n\t> git clone https://github.com/pmh/elf.git\r\n\t> mkdir my-lang\r\n\t> cd my-lang\r\n\t> npm link ../elf\r\n\r\nThis will create a 'node_modules' folder inside 'my-lang' containing the elf module.\r\n\r\n## Calculator\r\nTo help you understand the basics of elf let's use it to implement a simple calculator language so create a file called `calculator.js`.\r\nThe first thing you need to do is to require elf, so enter this into `calculator.js`:\r\n\t\r\n\tvar elf = require(\"elf\")\r\n\r\nThe next thing we will need is a lexer that can recognize numbers and operators (such as +, -, *, /), here's how that could be implemented:\r\n\t\r\n\tvar CalcLexer = elf.Lexer.clone(function () {\r\n\t\tthis.number(/\\d+/)\r\n\t\tthis.operator(/\\+|\\-|\\*|\\//)\r\n\t})\r\n\r\n`number` and `operator` are convenience methods implemented on top of the lower-level `rule` method so we could have implemented this more verbosely with `this.rule(\"number\", /\\d+/, this.helpers.number, \"literal\")`. Besides `number` and `operator` you can also use `name`, `string`, `regex`, `eol` and `skip`.\r\n\r\nSo now that we have our lexer, let's try it out but first add the following line just under the lexer:\r\n\r\n\tconsole.log(CalcLexer.lex(\"1+2*-3\")) //=> […tokens…]\r\n\r\nNow from a command line execute `node calculator.js` and you should se a list of tokens.\r\nThere's currently a problem with our lexer however, try adding spaces in the input string (eg. \"1 + 2 * 3\") and run it again. You will know see the same token list as before but with the addition of 'error' tokens everywhere a space was found. We can fix that by adding the following line to the lexer:\r\n\r\n\tvar CalcLexer = elf.Lexer.clone(function () {\r\n\t\t…\r\n\t\tthis.skip(/\\s+/)\r\n\t})\r\n\r\nWith our lexer i place, let's turn our attention to writing a parser.\r\nThe parser abstraction in elf is based on Vaughan Pratt's Top Down Operator Precedence algorithm, for more information about it read his [paper](http://hall.org.ua/halls/wizzard/pdf/Vaughan.Pratt.TDOP.pdf), there's also a couple of blog posts about it [here](http://javascript.crockford.com/tdop/tdop.html), [here](http://effbot.org/zone/simple-top-down-parsing.htm), [here](http://eli.thegreenplace.net/2010/01/02/top-down-operator-precedence-parsing/) and [here](http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/).\r\n\r\nFor our parser to work we have to deal with a few issues. First of all the '-' operator should be able to be used both in infix and prefix position and the '*' and '/' operators should have a higher precedence than '+' and '-'. Fortunately both of these features are elegantly handled by Pratt's algorithm:\r\n\r\n\tvar CalcParser = elf.Parser.clone(function () {\r\n\t\tthis.prefix(\"-\")\r\n\t\t\r\n\t\tthis.infix(\"+\", 10)\r\n\t\tthis.infix(\"-\", 10)\r\n\t\tthis.infix(\"*\", 20)\r\n\t\tthis.infix(\"/\", 20)\r\n\t});\r\n\t\r\n\t\r\n\tvar ast  = CalcParser.parse(\"1 + 2 * -3\", CalcLexer);\r\n\tvar sexp = elf.sexp(ast);\r\n\tconsole.log(sexp); //=> (+ 1 (* 2 (- 3)))\r\n\r\nHere we specify that '-' can appear in both prefix and infix locations we also specify that '+', '/' and '\\*' can appear in infix locations. The number we pass as the second argument to infix is it's precedence level so we assign '/' and '\\*' a higher precedence than '+' and '-'.\r\nTo use the parser we invoke it's `parse` method passing in the source and lexer, this gives us an AST which we then pass to `elf.sexp` which gives us a nicer representation for printing to the screen.\r\n\r\nHowever, since this is such a simple language it would be nice to just get the result of evaluating the input rather than an AST so let's do it:\r\n\r\n\tvar CalcEvaluator = elf.Parser.clone(function () {\r\n\t  this.prefix(\"(literal)\", function (token) { return token.value; })\r\n\t\r\n\t  this.prefix(\"-\", function () { return -this.expression(70) })\r\n\t\r\n\t  this.infix(\"+\", 10, function (token, left) { return left + this.expression(); })\r\n\t  this.infix(\"-\", 10, function (token, left) { return left - this.expression(); })\r\n\t  this.infix(\"*\", 20, function (token, left) { return left * this.expression(); })\r\n\t  this.infix(\"/\", 20, function (token, left) { return left / this.expression(); })\r\n\t});\r\n\t\r\n\tconsole.log(CalcEvaluator.parse(\"1 + 2 * -3\", CalcLexer)) //=> -5\r\n\r\nThere are two things to note here, the first is that we now add a prefix for the special '(literal)' symbol and specify that it should return it's value (in this case a number) rather than an AST node.\r\nThe second is that we pass in functions to the `prefix` and `infix` methods, this can be used by regular parsers too in order to add more information to the node, and indeed for more complex syntactic forms they are necessary.\r\n\r\nAs I previously stated, the above is fine for simple languages where interpretation/translation can be syntax directed but for more ambitious projects you typically walk the ast recursively to perform tasks such as optimization, dead code elimination, dependency resolution and code generation or interpretation.\r\nFor this task elf supplies the Walker:\r\n\r\n\tvar _;\r\n\t\r\n\tCalcWalker = elf.Walker.clone(function () {\r\n\t  // Match unary -\r\n\t  this.match (\"-\", [ _ ], function (node, left) {\r\n\t\treturn -this.walk(left);\r\n\t  })\r\n\t  \r\n\t  // Match binary -\r\n\t  this.match (\"-\", [ _ , _ ], function (node, left, right) {\r\n\t\treturn this.walk(left) - this.walk(right);\r\n\t  })\r\n\t\r\n\t  // Match binary +\r\n\t  this.match (\"+\", function (node, left, right) {\r\n    \treturn this.walk(left) + this.walk(right);\r\n\t  })\r\n\t  \r\n\t  // Match binary *\r\n\t  this.match (\"*\", function (node, left, right) {\r\n\t    return this.walk(left) * this.walk(right);\r\n\t  });\r\n\t  \r\n\t  // Match and optimize binary * when the right node is 2 by turning it into a left shift\r\n\t  this.match (\"*\", [ _ , 2 ], function (node, left, right) {\r\n\t    return this.walk(left) << 1;\r\n\t  });\r\n\t  \r\n\t  // Match binary /\r\n\t  this.match (\"/\", function (node, left, right) {\r\n\t    return this.walk(left) / this.walk(right);\r\n\t  });\r\n\t  \r\n\t  // Match any number and return it's value\r\n\t  this.match (\"number\", function (node) {\r\n\t    return node.value;\r\n\t  })\r\n\t});\r\n\t\r\n\tvar res = CalcWalker.walk(ast);\r\n\tconsole.log(res) //=> -5\r\n\r\nAs you can see it let's you match nodes based on their type or value and you can also optionally supply a pattern to be more specific. Undefined elements in a pattern are treated as catch-all so here we declare (but don't initialize) _, this means it will evaluate to undefined and so we can use that as the catch-all rather than typing out undefined everywhere. A pattern can also contain nested patterns, like: [2, [\"*\", 3, [\"+\", 4, 3\"]]].","note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"A DSL for creating reusable and extensible programming languages in JavaScript","name":"Elf","google":"UA-35665736-1"}