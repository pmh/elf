<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Elf by pmh</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <link rel="stylesheet" href="stylesheets/codemirror/codemirror.css">
    <script src="javascripts/scale.fix.js"></script>
    <script src="javascripts/elf.js"></script>
    <script src="javascripts/codemirror/codemirror.js"></script>
    <script src="javascripts/codemirror/mode/javascript/javascript.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <style type="text/css">
      .CodeMirror {
        border: 1px solid black;
        border-bottom: 0;
      }

      .CodeMirror-scroll {
        height: auto;
        overflow-y: hidden;
        overflow-x: auto;
      }

      .controls {
        background-color: #eee;
        height: 22px;
        padding: 5px;
        border: 1px solid black;
      }

      .runButton {
        float: right;
        width: 80px;
        height: 22px;
      }

      .output {
        /*background-color: #eee;*/
        padding: 5px;
        border: 1px solid black; 
        border-top: 0;
        font-family:monospace;
      }
    </style>

    <div class="wrapper">
      <header>
        <h1 class="header">Elf</h1>
        <p class="header">A DSL for creating reusable and extensible programming languages in JavaScript</p>

        <ul>
          <li class="download"><a class="buttons" href="https://github.com/pmh/elf/zipball/master">Download ZIP</a></li>
          <li class="download"><a class="buttons" href="https://github.com/pmh/elf/tarball/master">Download TAR</a></li>
          <li><a class="buttons github" href="https://github.com/pmh/elf">View On GitHub</a></li>
        </ul>

        <p class="header">This project is maintained by <a class="header name" href="https://github.com/pmh">pmh</a></p>


      </header>
      <section>
        <h1>ELF - Extensible Language Framework</h1>

<h2>Introduction</h2>

<p>ELF is an experimental compiler framework which let's you create reusable and extensible programming language implementations in JavaScript. It implements abstractions for creating languages with automatic error-recovery, easy handling of operator precedence, AST walkers with (basic) pattern-matching support and REPL's.</p>

<p>It takes advantage of JavaScript's prototypical nature so the way you create languages is by 'cloning' existing ones which in turn can be cloned by more specific ones. This, combined with the ability to mixin and borrow rules, makes it very easy to extend and compose existing languages.</p>

<h2>Installation</h2>

<pre><code>&gt; mkdir my-lang
&gt; cd my-lang
&gt; npm install elf.js
</code></pre>

<h2>Calculator Example</h2>

<div class="editor">
<textarea>
  var elf = require("../index"), _;

var Calculator = elf.Language.clone(function () {
  this.number   ( /\d+/        )
  this.name     ( /[a-zA-Z]+/  )

  this.prefix   ( "+", "-"     )

  this.infixr   ( "=", 10      )

  this.infix    ( "+", "-", 10 )
  this.infix    ( "*", "/", 20 )

  // Match functions in the form { x, y | x + y } or { 2 + 2 }
  this.prefix   ("{", function (node) {
    node.value  = "(function)";
    node.first  = this.parseUntil("|", { step: ",", abort_if: "}", meta: { type: "parameter" } })
    node.second = this.parseUntil("}");

    return node;
  })

  // Match function invocations in the form foo(2, 3)
  this.infix  ("(", 80, function (node, first) {
    node.value  = "(call)";
    node.first  = first;
    node.second = this.parseUntil(")", { step: "," })

    return node;
  });

  this.stmt ("print")

  this.skip ( /\s+/ )
  this.eol  ( /\;/  )
});

Evaluator = elf.Walker.clone(function () {

  // Match unary -
  this.match ("-", [ _ ], function (env, node, left) {
    return -this.walk(left, env);
  })

  // Match binary -
  this.match ("-", [ _ , _ ], function (env, node, left, right) {
    return this.walk(left, env) - this.walk(right, env);
  })

  // Match unary +
  this.match ("+", [ _ ], function (env, node, left) {
    return +this.walk(left, env);
  })

  // Match binary +
  this.match ("+", [ _ , _ ], function (env, node, left, right) {
    return this.walk(left, env) + this.walk(right, env);
  })

  // Match binary *
  this.match ("*", function (env, node, left, right) {
    return this.walk(left, env) * this.walk(right, env);
  });

  // Match and "optimize" binary * when the right node is 2 by turning it into a left shift
  this.match ("*", [ _ , 2 ], function (env, node, left) {
    return this.walk(left, env) << 1;
  });

  // Match binary =
  this.match ("=", [ "(name)", _ ], function (env, node, left, right) {
    return env[left.value] = this.walk(right, env);
  });

  // Match binary /
  this.match ("/", function (env, node, left, right) {
    return this.walk(left, env) / this.walk(right, env);
  })

  // Match print statements
  this.match ("print", function (env, node, right) { 
    return console.log(this.walk(right, env));
  })

  // Match function statements
  this.match("(function)", function (env, node, params, body) {
    var self = this;
    return function () {
      var args = arguments;
      env = env.clone();
      params.forEach(function (param, idx) { env[self.walk(param, env)] = args[idx]; }, self);
      return self.walk(body, env).pop();
    };
  });

  // Match function calls
  this.match ("(call)", function (env, node, left, right) {
    var res = this.walk(left, env).apply(null, this.walk(right, env));
    return res;
  });

  // Match identifiers
  this.match ("(name)", function (env, node) {
    return env[node.value];
  });

  // Match anything else and return it's value
  this.match (_, function (env, node) {
    return node.value;
  })
});

var ast = Calculator.parse("print 1 + 2 * 3; print { x, y | x - y }(4, 2);");

Evaluator.walk(ast);
</textarea>
</div>

<h2>API</h2>

<h3>elf.Object</h3>

<p><strong>Provides an abstraction over JavaScript's implementation of protoypal inheritence.</strong></p>
<div class="editor">
  <textarea>var elf = require('elf.js');

var Person = elf.Object.clone(function () {
  this.greet = function (person, message) { console.log(this.name + " says: " + message + ' ' + person.name + '!'); }

  this.init  = function () { this.name = "Anonymous" }
});

var patrik = Person.clone({name: "Patrik"});
var anon   = Person.clone();

patrik.greet(anon, "Hello");

patrik.extend({age: 27}, {occupation: "Hacker"});
patrik.describe = function () {
  console.log("name:", this.name + ", age:", this.age + ", occupation:", this.occupation);
};

patrik.describe();

console.log('slots:', patrik.slots());
</textarea>
</div>
<br />
<ul>
<li>
<p><code>.clone(initializer&lt;function|object&gt;)</code></p>

<p><em>Returns a new object whose prototype link points to the object being cloned. It accepts either a function or an object with initialization logic which will be applied to the new object.</em></p>
</li>
<li>
<p><code>.extend(â€¦mixins)</code></p>

<p><em>Copies all properties from each of the mixin objects over to itself.</em></p>
</li>
<li>
<p><code>.slots()</code></p>

<p><em>Returns an array of all it's properties.</em></p>
</li>
</ul><h3>elf.Token</h3>

<p><strong>Represents a lexical token.</strong></p>

<div class="editor">
  <textarea>var elf = require('elf.js');
var token = elf.Token.create('string', 'foo');
token.pos({start: 0, end:3, line: 0});

console.log(token);
  </textarea>
</div>
<br />
<ul>
<li>
<p><code>.create(type, value)</code></p>

<p><em>Creates and returns a new token object from the current one with type, value and an optional arity set.</em></p>
</li>
<li>
<p><code>.error(message&lt;string&gt;)</code></p>

<p><em>Turns the token into an error token. Returns the current token instance.</em></p>
</li>
<li>
<p><code>.pos(pos&lt;object&gt;)</code></p>

<p><em>Updates the token position. Returns the current token instance.</em></p>
</li>
</ul><h3>elf.Lexer</h3>

<p><strong>Provides a lexer abstraction on top of which you can base your own more specific lexers. It resolves ambiguity by always selecting the longest match and in cases where there are multiple equally long matches it chooses the last one.</strong></p>

<div class="editor">
  <textarea>var elf = require('elf.js');

var MyLexer = elf.Lexer.clone(function () {
  
  this.name(/[a-zA-Z]+/)

  this.operator("+")

  // This is the equivalent of this.number(/\d+/)
  this.rule("number", /\d+/, function (num) { return parseFloat(num, 10); }, "(literal)")

  // this is the equivalent as this.skip(/\s+/)
  this.rule('ws', /\s+/, function () { return null; });
});

var tokens = MyLexer.lex('foo + 3');
console.log(tokens);
</textarea>
</div>
<br />

<ul>
<li>
<p><code>.name(match&lt;regexp|string&gt; [, action&lt;function&gt;])</code></p>

<p><em>Creates a rule for matching identifiers based on the provided match object.</em></p>
</li>
<li>
<p><code>.number(match&lt;regexp|string&gt; [, action&lt;function&gt;])</code></p>

<p><em>Creates a rule for matching number literals based on the provided match object.</em></p>
</li>
<li>
<p><code>.string(match&lt;regexp|string&gt; [, action&lt;function&gt;])</code></p>

<p><em>Creates a rule for matching strings literals based on the provided match object.</em></p>
</li>
<li>
<p><code>.regex(match&lt;regexp|string&gt; [, action&lt;function&gt;])</code></p>

<p><em>Creates a rule for matching regex literals based on the provided match object.</em></p>
</li>
<li>
<p><code>.operator(match&lt;regexp|string&gt; [, action&lt;function&gt;])</code></p>

<p><em>Creates a rule for matching operators based on the provided match object.</em></p>
</li>
<li>
<p><code>.eol(match&lt;regexp|string&gt; [, action&lt;function&gt;])</code></p>

<p><em>Creates a rule for matching end-of-line operators based on the provided match object.</em></p>
</li>
<li>
<p><code>.skip(match&lt;regexp|string&gt;)</code></p>

<p><em>Tells the lexer to skip anything matching the provided match object.</em></p>
</li>
<li>
<p><code>.rule(name, regex, action [, arity])</code></p>

<p><em>A lower-level matcher that all of the previous ones are based upon.</em></p>

<p><em>All of the above methods accepts an optional action function that will be invoked when the rule matches. The context inside the action is the matched string. It can return one of three things: a value (which will be set as the value on the current token), an array of tokens or null (in which case the lexer will ignore the match).</em></p>
</li>
</ul><h3>elf.Parser</h3>

<p><strong>Provides a parser abstraction on top of which you can base your own more specific parsers. It's based on Vaughan R. Pratt's "Top Down Operator Precedence" algorithm which you can read more about <a href="http://hall.org.ua/halls/wizzard/pdf/Vaughan.Pratt.TDOP.pdf" target="_blank">here</a>, <a href=http://javascript.crockford.com/tdop/tdop.html"" target="_blank">here</a>, <a href="http://effbot.org/zone/simple-top-down-parsing.htm" target="_blank">here</a>, <a href="http://eli.thegreenplace.net/2010/01/02/top-down-operator-precedence-parsing/" target="_blank">here</a> and <a href="http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/" target="_blank">here</a>.</strong></p>

<div class="editor">
  <textarea>var elf = require('elf.js');

var MyLexer = elf.Lexer.clone(function () {
  this.number(/\d+/);
  this.operator(/\+|\*/);
  this.skip(/\s+/)
});

var MyParser = elf.Parser.clone(function () {
  this.infix("+", 10)
  this.infix("*", 20)
});

var tokens = MyLexer.lex('2 + 4 * 4');
var ast    = MyParser.parse(tokens);
console.log(ast.toSexp());
</textarea>
</div>
<br />

<ul>
<li>
<p><code>.advance([id])</code></p>

<p><em>Advances to the next token, if an id is provided an error node will be created if it doesn't match the id of that token.</em></p>
</li>
<li>
<p><code>.expression([rbp])</code></p>

<p><em>Parses a single expression, if an rbp (right binding power) is provided then it will only parse as long as the next token has the same binding power or higher.</em></p>
</li>
<li>
<p><code>.statement()</code></p>

<p><em>Parses a single statement.</em></p>
</li>
<li>
<p><code>.parseUntil(closeTag [, opts{step<string>, meta<object>, abort_if<string>}])</code></p>

<p><em>Keeps parsing statements until it encounters the closeTag or aborts if it encounters the value of the optional abort_if option.</em></p>
</li>
<li>
<p><code>.stmt(id, std&lt;function(node)&gt;)</code></p>

<p><em>Creates a rule for matching a statement. A statement can only appear at the beginning of an expression.</em></p>
</li>
<li>
<p><code>.prefix(id [, nud&lt;function(node)&gt;])</code></p>

<p><em>Creates a rule for matching prefix tokens, similar to stmt exept that it can appear multiple times in an expression.</em></p>
</li>
<li>
<p><code>.infix(id, bp [, led&lt;function(node, left)&gt;])</code></p>

<p><em>Creates a rule for matching tokens in infix position. Can appear multiple times in an expression.</em></p>
</li>
<li>
<p><code>.infixr(id, bp [, led&lt;function(node, left)&gt;])</code></p>

<p><em>Like infix except that it associates to the right.</em></p>
</li>
<li>
<p><code>.borrow(parser, ...rules)</code></p>

<p><em>Let's you borrow a set of rules from another parser.</em></p>
</li>
<li>
<p><code>.token</code></p>

<p><em>Always points to the current token.</em></p>
</li>
<li>
<p><code>.tokens</code></p>

<p><em>A collection of all the remaining tokens. It has a <code>.peek([n])</code> method that let's you look at the next token without consuming it.</em></p>
</li>
<li>
<p><code>.parse(tokens&lt;Array&gt;)</code></p>

<p><em>Accepts a collection of tokens and returns an AST.</em></p>
</li>
</ul><h3>elf.Language</h3>

  <p><strong>Provides a unified abstraction for lexers and parsers.</strong></p>

<div class="editor">
  <textarea>var elf = require('elf.js');

var MyLanguage = elf.Language.clone(function () {
  this.number(/\d+/);

  this.infix("+", 10)
  this.infix("*", 20)

  this.skip(/\s+/)
});

var ast = MyLanguage.parse('2 + 4 * 4');
console.log(ast.toSexp());
</textarea>
</div>
<br />


<ul>
<li>
<p><code>.name(regex&lt;regexp|string&gt; [, action&lt;function(token)&gt;])</code></p>

<p><em>Creates a rule for matching identifiers based on the provided match object.</em></p>
</li>
<li>
<p><code>.number(regex&lt;regexp|string&gt; [, action&lt;function(token)&gt;])</code></p>

<p><em>Creates a rule for matching numbers based on the provided match object.</em></p>
</li>
<li>
<p><code>.string(regex&lt;regexp|string&gt; [, action&lt;function(token)&gt;])</code></p>

<p><em>Creates a rule for matching strings based on the provided match object.</em></p>
</li>
<li>
<p><code>.regex(regex&lt;regexp|string&gt; [, action&lt;function(token)&gt;])</code></p>

<p><em>Creates a rule for matching regular expressions based on the provided match object.</em></p>
</li>
<li>
<p><code>.eol(regex&lt;regexp|string&gt; [, action&lt;function(token)&gt;])</code></p>

<p><em>Creates a rule for matching end-of-line operators based on the provided match object.</em></p>
</li>
<li>
<p><code>.skip(regex&lt;regexp|string&gt; [, action&lt;function(token)&gt;])</code></p>

<p><em>Tells the language to skip anything matching the provided match object.</em></p>

<li>
  <p><code>.stmt(id&lt;string&gt;, std&lt;function(node)&gt;)</code></p>
  <p><em>Creates a rule for matching a statement. A statement can only appear at the beginning of an expression.</em></p>
</li>

</li>
<li>
<p><code>.prefix(id&lt;string&gt; [, nud&lt;function(node)&gt;])</code></p>

<p><em>Creates a rule for matching prefix tokens, similar to stmt exept that it can appear multiple times in an expression.</em></p>
</li>
<li>
<p><code>.infix(id&lt;string&gt;, bp&lt;integer&gt; [, led&lt;function(node, left)&gt;])</code></p>

<p><em>Creates a rule for matching tokens in infix position. Can appear multiple times in an expression.</em></p>
</li>
<li>
<p><code>.infixr(id&lt;string&gt;, bp&lt;integer&gt; [, led&lt;function(node, left)&gt;])</code></p>

<p><em>Like infix except that it associates to the right.</em></p>
</li>
<li>
<p><code>.borrow(language, ...rules)</code></p>

<p><em>Let's you borrow a set of rules from another language.</em></p>
</li>
<li>
<p><code>.parse(input&lt;string&gt;)</code></p>

<p><em>Accepts a program string and returns an AST.</em></p>
</li>
</ul><h3>elf.Walker</h3>

  <p><strong>Recursively walks the AST and applies your matchers.</strong></p>

<div class="editor">
  <textarea>var elf = require('elf.js'), _;

var MyLanguage = elf.Language.clone(function () {
  this.number(/\d+/);

  this.infix("+", 10)
  this.infix("*", 20)

  this.stmt('print', function (node) {
    node.first = this.expression();
    node.arity = "statment";
    return node;
  })

  this.skip(/\s+/)
});

var MyWalker = elf.Walker.clone(function () {
  this.match("+", function (node, left, right) {
    return this.walk(left) + this.walk(right);
  })

  this.match("*", function (node, left, right) {
    return this.walk(left) * this.walk(right);
  })

  this.match("print", function (node, right) {
    console.log(this.walk(right));
  })

  this.match(_, function (node) {
    return node.value;
  })
});

var ast = MyLanguage.parse('print 2 + 4 * 4');
MyWalker.walk(ast);
</textarea>
</div>
<br />

<ul>
<li>
<p><code>.match(match&lt;string|number&gt; [, pattern&lt;array&gt;], action&lt;function(node, child1, child2, â€¦, childN)&gt;)</code></p>

<p><em>Executes the action if the type or value of the current node matches the match argument and if the provided (optional) pattern.</em></p>
</li>
<li>
<p><code>.walk(ast&lt;AST|Node|Array&gt;)</code></p>

<p><em>Walks the ast and returns whatever your actions return.</em></p>
</li>
</ul>

<h3>elf.ErrorWalker</h3>

  <p><strong>Recursively walks the AST collecting error nodes.</strong></p>

<div class="editor">
  <textarea>var elf = require('elf.js'), _;

var MyLanguage = elf.Language.clone(function () {
  this.number(/\d+/);

  this.infix("+", 10)
  this.infix("*", 20)

  this.stmt('print', function (node) {
    node.first = this.expression();
    node.arity = "statment";
    return node;
  })

  this.skip(/\s+/)
});

var source   = 'print !!? + 4 ** 4';
var ast      = MyLanguage.parse(source);
var errorMsg = elf.ErrorWalker.report(ast, source);

console.log(errorMsg);
</textarea>
</div>
<br />

<ul>
<li>
<p><code>.report(ast&lt;ast|node|array&gt;, source&lt;string&gt;)</code></p>

<p><em>Walks the ast and generates an error report.</em></p>
</li>
</ul>

<h3>elf.REPL</h3>

  <p><strong>Creates a REPL for your language.</strong></p>

<div class="editor disabled">
  <textarea>var elf = require('elf.js'), REPL;

REPL = elf.REPL.clone({
  eval: function (cmd) {
    var ast = Calculator.parse(cmd);
    return Evaluator.walk(ast)[0];
  }
});

REPL.on('exit', function () {
  console.log('Goodbye!');
});

REPL.start();
</textarea>
</div>
<br />

<ul>
<li>
<p><code>.reader</code></p>

<p><em>Defaults to readline.</em></p>
</li>

<li>
<p><code>.in</code></p>

<p><em>Defaults to process.stdin.</em></p>
</li>

<li>
<p><code>.out</code></p>

<p><em>Defaults to process.stdout.</em></p>
</li>

<li>
<p><code>.colorize</code></p>

<p><em>A function that colorizes the output. Defaults to sys.inspect.</em></p>
</li>

<li>
<p><code>.eval</code></p>

<p><em>A function that evaluates the input, you should override this. Defaults to regular eval.</em></p>
</li>

<li>
<p><code>.start</code></p>

<p><em>Kicks off the read-eval-print-loop.</em></p>
</li>
</ul>

<p><strong>-- Events</strong></p>

<ul>
<li>
<p><code>line</code></p>

<p><em>Triggered on every read.</em></p>
</li>


<li>
<p><code>.close</code></p>

<p><em>Triggered as the session ends.</em></p>
</li>

</ul>
      </section>
      <footer>
        <p><small>Hosted on <a href="https://pages.github.com">GitHub Pages</a> using the Dinky theme</small></p>
      </footer>
    </div>

    <script type="text/javascript">
      var iframe = document.createElement("iframe");
      iframe.style.display = "none";
      document.body.appendChild(iframe);

      // write a script into the <iframe> and create the sandbox
      frames[frames.length - 1].document.write(
        "<script>"+
        "var MSIE/*@cc_on =1@*/;"+ // sniff
        "parent.sandbox=MSIE?this:{eval:function(s){return eval(s)}}"+
        "<\/script>"
      );


      var createEditorFrom = function (editorContainer) {
        var editor         = CodeMirror.fromTextArea(editorContainer.getElementsByTagName('textarea')[0], {lineNumbers: true});
        var controls       = document.createElement("div");
        controls.className = "controls";
        var run            = document.createElement("button");
        run.className      = "runButton";
        run.textContent    = "Run";
        controls.appendChild(run);
        editorContainer.appendChild(controls)

        var clickHandler = function () {
          
          var output = editorContainer.getElementsByClassName('output')[0];
          if (!output) {
            output           = document.createElement('div');
            output.className = 'output';
            editorContainer.appendChild(output);
          }
          var res = '<span style="font-weight:bold;">Output:</span>';
          iframe.contentWindow.console.log = function() {
            var messages = [];
            // Convert all arguments to Strings (Objects will be JSONified).
            for (var i = 0; i < arguments.length; i++) {
              var value = arguments[i];
              messages.push(typeof(value) == 'object' ? JSON.stringify(value) : String(value).replace(/\ /g, '&nbsp;').replace(/\n+/g, '<br />'));
            }
            var msg = messages.join(" ");
            res += "<br />" + msg;
          };
          iframe.contentWindow.require = function () { return elf; };
          sandbox.eval(editor.getValue());
          output.innerHTML = res;
        };

        run.addEventListener ? run.addEventListener('click', clickHandler, false) : run.attachEvent('click', clickHandler);
      }

      var editors = document.getElementsByClassName('editor');
      for (var i = 0; i < editors.length; i++)
        createEditorFrom(editors[i]);

      document.getElementsByClassName('disabled')[0].getElementsByTagName('button')[0].disabled = true;
    </script>


    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-35665736-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>
